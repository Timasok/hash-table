# Отчёт по работе Хэш Таблицы

## Введение

**Хэш-функция** - функция, преобразующая произвольный массив входных данных в битовую строку установленной длины. Подобное преобразование называется **хешированием**.

**Хэш-таблица** - структура данных, реализующая интерфейс ассоциативного массива (все элементы хранятся в виде пары ключ-значение). Она позволяет выполнять три операции: добавление новой пары, удаление пары и поиск пары по ключу.

Выполнение каждой операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Хеш-код $i = hash(key)\pmod{TAB_SIZE}$ играет роль индекса в массиве `H`. В дальнейшем пару ключ-значение помещают в ячейку`H[i]`.

*общая схема хэш таблиц для массива `H`:* - ВСТАВИТЬ КАРТИНКУ

Помимо массива с открытой адресацией есть вариант хэш-таблицы со списками. В таком случае каждая ячейка массива хранит список элементов. Такая реализация необходима в случае возникновения **коллизий**, т.е. совпадения хэша от двух различных ключей. *Мы будем применять её для работы со строками.* 

Основные характеристики хэш-таблиц:

**Заселённость**(Число коллизий) - это длина списка. В хэш-таблице с открытой адресацией данная характеристика не имеет смысла, т.к. рана 1 для каждого `H[i]`.

**Коэффициент заполнения(a)** - число элементов в хэш-таблице, делённое на её размер. Коэффициент заполнения определяет среднее время поиска по хэш-таблице. Для идеальной хэш-функции коэффициент заполнения равен средней длине списка.

## Цель работы

Изучение хэш-таблиц и освоение передовых методов оптимизации.

## План работы

Создать хэш-таблицу на основе списков из строк, а затем произвести следующие исследования:

1. Сравнить работу различных хэш-функций. Для этого построить гистограммы заселённости и посчитать дисперсию для каждого случая. Как итог оставить наилучшую хэш-функцию. 
2. Оптимизировать время поиска по хэш-таблице. Для этого использовать статистику вызова функций от утилиты `kachegrind`. Для чаще всего используемых функций провести оптимизацию ассемблерными вставками и `SIMD`-инструкциями.

## Экспериментальная установка


## Исходные данные

Трилогия Дж.Р.Р.Толкиена Властелин Колец в оригинале. Количество уникальных слов состовило `15410`.

## Использованные утилиты

## Часть 1. Исследование хэш-функций

### Размер хэш-таблицы

Для начала выберем размер таблицы(`TAB_SIZE`) таким образом, чтобы коэффициент заполнения(`a`) получился равен `15`. 
$a = \frac{NUMBER_OF_ELEMENTS,TAB_SIZE} ->  TAB_SIZE = \frac{NUMBER_OF_ELEMENTS,a} =  \frac{1540,15} ≈ 1001$

Также необходимо размер таблицы округлить до простого числа, чтобы при вычислении хэш-кода `i` не возникло дополнительных коллизий. Например, если выполняются условия:
+ $hash(key_1) = hash(key_2)*C$ 
+ $hash(key_1) > TAB_SIZE$ 
+ $TAB_SIZE ⁞ С$
то пары с ключами 1 и 2 попадут в один список.

### Хэш-первая буква

Функция возвращает первый байт строки.

```C++
__uint32_t hash_first_letter(const char * string)
{
    return (__uint32_t)string[0];
}
```

![First_letter](analysis/First_letter-results.png)

### Хэш-сумма

Функция возвращает сумму ASCII кодов символов.

```C++
__uint32_t hash_ascii_sum(const char * string)
{
    __uint32_t result = 0;
    int idx = 0;

    for(;string[idx] != '\0'; idx++)
        result += string[idx];

    return result;
}
```

![Ascii_sum](analysis/Ascii_sum-results.png)

### ROR-хэш

Функция основана на алгоритме циклического сдвига вправо.

```C++
static inline __uint32_t ror(__uint32_t original, __uint32_t bits)  
{
    return (original >> bits) | (original << (32 - bits));

}

__uint32_t hash_rotate_right(const char *string)
{
    __uint32_t hash = 0;
    
    while(*string)
    {
        hash = ror(hash, 1)^*(string++);
    }

    return hash;
}
```

Заселённость хэш-таблицы с ROR-хэш:

![Rotate_right](analysis/Rotate_right-results.png)

### ROL-хэш

Функция основана на алгоритме циклического сдвига влево.

```C++
static inline __uint32_t rol(__uint32_t original, __uint32_t bits)  
{
    return (original << bits) | (original >> (32 - bits));
}

__uint32_t hash_rotate_left(const char *string)
{
    __uint32_t hash = 0;
    
    while(*string)
    {
        hash = rol(hash, 1)^*(string++);
    }

    return hash;
}
```

Заселённость хэш-таблицы с ROR-хэш:

![Rotate_left](analysis/Rotate_left-results.png)

### GNU-хэш

```C++
__uint32_t hash_gnu(const char *string)
{
    __uint32_t hash = 5381;         // стартовый размер таблицы

    int idx = 0;

    for(;string[idx] != '\0'; idx++)
        hash = ((hash << 5) + hash) + string[idx];

    return hash;
}
```

Заселённость хэш-таблицы с GNU хэш:

![GNU](analysis/GNU-results.png)

### Результаты измерений

![Dispersion](analysis/Dispersion-results.png)


## Часть 2. Оптимизация поиска по хэш-таблице

<!-- 

#### Простейший алгоритм

#### Оптимизированный алгоритм

#### Погрешности измерений

#### Измерения

### Часть 2. Alpha Blending

#### Теоретическая справка

#### Простейший алгоритм

#### Оптимизированный алгоритм

#### Погрешности измерений

#### Измерения -->

## Результаты

## Источники и литература